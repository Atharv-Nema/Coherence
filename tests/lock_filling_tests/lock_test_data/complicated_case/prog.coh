/*
Complicated SCC
Looks like:

  |────▶ G
  |
Tail ──▶ A ──▶ B ──▶ C ──▶ F
        ▲           │
        │           ├──▶ D ──▶ E
        └───────────┘    ▲    │
                         └────┘

H    (isolated)
*/

func A() => unit {
    atomic { 
        var lock_var: int locked<A> = (new[1] int(1));
        lock_var[0];
    }
    return B();
}

func B() => unit {
    atomic { 
        var lock_var: int locked<B> = (new[1] int(1));
        lock_var[0]; 
    }
    return C();
}

func C() => unit {
    atomic { 
        var lock_var: int locked<C> = (new[1] int(1));
        lock_var[0]; 
    }
    A();        // closes triangle SCC
    D();        // enters second SCC
    F();        // fan-out
    return ();
}

func D() => unit {
    atomic { 
        var lock_var: int locked<D> = (new[1] int(1));
        lock_var[0]; 
    }
    return E();
}

func E() => unit {
    atomic { 
        var lock_var: int locked<E> = (new[1] int(1));
        lock_var[0]; 
    }
    return D();        // D <-> E SCC
}

func F() => unit {
    atomic { 
        var lock_var: int locked<F> = (new[1] int(1));
        lock_var[0]; 
    }
    return ();
}

func G() => unit {
    atomic { 
        var lock_var: int locked<G> = (new[1] int(1));
        lock_var[0]; 
    }
    return ();
}

func Tail() => unit {
    atomic { 
        var lock_var: int locked<Tail> = (new[1] int(1));
        lock_var[0]; 
    }
    A();
    G();
    return ();
}

func H() => unit {
    atomic { 
        var lock_var: int locked<H> = (new[1] int(1));
        lock_var[0]; 
    }
    return ();
}

actor Main {
    new create() {}
}